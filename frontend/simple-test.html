<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple WebRTC Test - Saathi TV</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }
        
        .container {
            background: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        
        .status {
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            font-weight: bold;
            text-align: center;
        }
        
        .status.disconnected { background: #f8d7da; color: #721c24; }
        .status.connecting { background: #fff3cd; color: #856404; }
        .status.waiting { background: #cce5ff; color: #004085; }
        .status.connected { background: #d4edda; color: #155724; }
        
        .controls {
            text-align: center;
            margin: 20px 0;
        }
        
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin: 0 10px;
        }
        
        button:hover { background: #45a049; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        
        .videos {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }
        
        video {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 10px;
        }
        
        .online-count {
            background: #4CAF50;
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
            margin: 10px 0;
        }
        
        .log {
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 15px;
            height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üé• Simple WebRTC Test</h1>
        
        <div class="online-count">
            üë• Online Users: <span id="onlineCount">0</span>
        </div>
        
        <div class="status disconnected" id="status">
            üì° Status: Connecting to server...
        </div>
        
        <div class="controls">
            <button id="findBtn" onclick="findMatch()" disabled>üîç Find Match</button>
            <button id="nextBtn" onclick="nextUser()" disabled>‚è≠Ô∏è Next User</button>
        </div>
        
        <div class="videos">
            <div>
                <h3>üìπ Your Video</h3>
                <video id="localVideo" autoplay muted playsinline></video>
            </div>
            <div>
                <h3>üë§ Remote Video</h3>
                <video id="remoteVideo" autoplay playsinline></video>
            </div>
        </div>
        
        <div class="log" id="log"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script>
        let socket = null;
        let localStream = null;
        let peerConnection = null;
        let currentRoom = null;
        
        const rtcConfig = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            log('üöÄ Starting simple WebRTC test...');
            
            try {
                await getUserMedia();
                connectToServer();
            } catch (error) {
                log(`‚ùå Error: ${error.message}`);
                updateStatus('Error: ' + error.message, 'disconnected');
            }
        });
        
        async function getUserMedia() {
            log('üìπ Getting user media...');
            
            localStream = await navigator.mediaDevices.getUserMedia({
                video: true,
                audio: true
            });
            
            document.getElementById('localVideo').srcObject = localStream;
            log('‚úÖ Got local video stream');
        }
        
        function connectToServer() {
            log('üîå Connecting to server...');
            
            socket = io('http://localhost:3000');
            
            socket.on('connect', () => {
                log('‚úÖ Connected to server');
                updateStatus('Connected - Ready to find match', 'connected');
                document.getElementById('findBtn').disabled = false;
            });
            
            socket.on('disconnect', () => {
                log('‚ùå Disconnected from server');
                updateStatus('Disconnected', 'disconnected');
                cleanup();
            });
            
            socket.on('online_count', ({ count }) => {
                document.getElementById('onlineCount').textContent = count;
                log(`üë• Online users: ${count}`);
            });
            
            socket.on('waiting', ({ message }) => {
                log(`‚è≥ ${message}`);
                updateStatus(message, 'waiting');
            });
            
            socket.on('matched', async ({ roomId, peer1, peer2 }) => {
                log(`üéâ Matched! Room: ${roomId}`);
                updateStatus('Matched! Connecting...', 'connecting');
                
                currentRoom = roomId;
                const isInitiator = peer1 === socket.id;
                
                await createPeerConnection(isInitiator);
                document.getElementById('nextBtn').disabled = false;
            });
            
            socket.on('signal', async ({ signal }) => {
                log(`üì° Received signal: ${signal.type || 'ice-candidate'}`);
                await handleSignal(signal);
            });
            
            socket.on('peer_left', () => {
                log('üëã Peer left');
                updateStatus('Peer disconnected', 'disconnected');
                cleanup();
            });
            
            socket.on('connect_error', (error) => {
                log(`‚ùå Connection error: ${error.message}`);
                updateStatus('Connection failed', 'disconnected');
            });
        }
        
        function findMatch() {
            if (!socket || !socket.connected) {
                log('‚ùå Not connected to server');
                return;
            }
            
            log('üîç Looking for match...');
            updateStatus('Looking for someone...', 'connecting');
            socket.emit('find_match');
            document.getElementById('findBtn').disabled = true;
        }
        
        async function createPeerConnection(isInitiator) {
            log(`üîó Creating peer connection (initiator: ${isInitiator})`);
            
            peerConnection = new RTCPeerConnection(rtcConfig);
            
            // Add local stream
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('signal', {
                        roomId: currentRoom,
                        signal: { candidate: event.candidate }
                    });
                }
            };
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                log('üé• Got remote stream!');
                document.getElementById('remoteVideo').srcObject = event.streams[0];
                updateStatus('Connected! üéâ', 'connected');
            };
            
            // Create offer if initiator
            if (isInitiator) {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                socket.emit('signal', {
                    roomId: currentRoom,
                    signal: { type: 'offer', sdp: offer.sdp }
                });
            }
        }
        
        async function handleSignal(signal) {
            if (signal.type === 'offer') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                socket.emit('signal', {
                    roomId: currentRoom,
                    signal: { type: 'answer', sdp: answer.sdp }
                });
            } else if (signal.type === 'answer') {
                await peerConnection.setRemoteDescription(new RTCSessionDescription(signal));
            } else if (signal.candidate) {
                await peerConnection.addIceCandidate(new RTCIceCandidate(signal.candidate));
            }
        }
        
        function nextUser() {
            log('‚è≠Ô∏è Finding next user...');
            if (currentRoom) {
                socket.emit('leave_room', { roomId: currentRoom });
            }
            cleanup();
            setTimeout(() => findMatch(), 1000);
        }
        
        function cleanup() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            document.getElementById('remoteVideo').srcObject = null;
            currentRoom = null;
            document.getElementById('findBtn').disabled = false;
            document.getElementById('nextBtn').disabled = true;
        }
        
        function updateStatus(text, type) {
            const statusEl = document.getElementById('status');
            statusEl.textContent = `üì° Status: ${text}`;
            statusEl.className = `status ${type}`;
        }
        
        function log(message) {
            const logEl = document.getElementById('log');
            const time = new Date().toLocaleTimeString();
            logEl.innerHTML += `<div>[${time}] ${message}</div>`;
            logEl.scrollTop = logEl.scrollHeight;
            console.log(message);
        }
    </script>
</body>
</html>
